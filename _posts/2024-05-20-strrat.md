---
title: "Strrat technical analysis"
date: "2025-05-20 00:00:00"
categories: [misc]
tags: [misc]
---

# Sample Info

| SHA256|
|---------------------------------------------------------------------------------|
|5c65955da2b6e996c378858d6a886bad85e969fd42509053794cb8ad64630894 |

* Size:  356.650 bytes
* First seen:  2024-05-11 07:06:46 UTC
* File Type:  .js

# Analysis
I found the sample on malware bazaar and wanted to take a look at jscript malware after a long while

# Stage 1
After running it through an deobfuscator to make it more readable, I can finally start analysing.
The first part defines some functions vital for decrypting the second stage. This is done using JavaScript's "String.prototype".


![image](https://github.com/vrrmin/re-stuff/assets/97342354/1cf3a6c8-334a-4795-9a0d-d792e4991ec2)

* function xX7r0lQ() => this function resolves a string using a "key", which is then stored in the variable (function) "PRNT_LN". Instead of taking inputs, this function uses "this" to access the "key". The "key" is a sequence of numbers in string-form.
* function load(cont, str, nid) => load() has two purposes: first, it is used to store the result of xX7r0lQ's results in "PRNT_LN"

As mentioned, the main decrypt function uses a sequence of numbers to resolve a full string by taking a substring according to the numbers.
This function writes "prototype" in the variable "PRNT_LN", which is used below to define the void function "h5aLFnU"

* function h5aLFnU => basically replaces "placeholders" in a string with given string(s). 

There is a big chunk of b64 with tons of these placeholders. These will get replaced and the result is the second stage with b64 encryption.
![image](https://github.com/vrrmin/re-stuff/assets/97342354/506fdecb-fa9b-4e30-9370-43921c438fd2)


The code creates the WSH Object "microsoft.xmldom", which is used to decrypt the b64 and then run it using the eval() function later on. Before that, the code gets written onto an array using the WSH Object "adodb.stream". Then the execution of the second stage begins.

# Stage 2

![image](https://github.com/vrrmin/re-stuff/assets/97342354/5a7fb246-f4d6-4d23-9c8b-c96ecb74ad81)

The second stage is not as interesting. It decodes a huge b64 chunk using regex, writes it to /appdata/roaming and executes the decoded .jar file via jre. If jre is not installed, it installs it. The next stage is a .jar file, which gets executed.

# Stage 3

Running the .jar file through virustotal we get 39/66 detections and the sample is classified as STRRAT, a java based remote administration tool.

| SHA256|
|---------------------------------------------------------------------------------|
|486b68ef93d03c4e486b8ddd9e153391e7debc6839e0c09d38999dd159e30705 |

The file is obfuscated with Zelix Klassmaster. To deobfuscate it, I used this: https://github.com/java-deobfuscator/deobfuscator. After that the code is more readable and comprehensive and I started looking for the config and decrypt it. The config is encrypted using AES and is stored in base64 format in the ressources section in the file config.txt. For decompilation, I used Recaf.

![image](https://github.com/vrrmin/re-stuff/assets/97342354/dc9abd37-0eae-4e65-9c38-3ec6bf819926)

I wrote a decryptor for the file, which I'll include and the result is this:

![image](https://github.com/vrrmin/re-stuff/assets/97342354/a7aceb9a-08c4-4c2c-8826-e77fcad80c4b)

This includes the C2 server and IP, and something that looks like a password or key.

* C2: 79[.]110[.]62[.]41
* URL: hxxp://jbfrost[.]live/strigoi/server/?hwid=1&lid=m&ht=5
* Key?: 0EHD-YGMT-QM81-RD7S-07I6


Functions of STRRAT:

![image](https://github.com/vrrmin/re-stuff/assets/97342354/71926af7-c722-46fc-94b6-cb8c8094b642)

This malware can grab passwords, do actions on your computer and even encrypt files. 


# Conclusion

This sample tries to hide its malicious intent via heavy javascript obfuscation. Funnily, if java is not installed on the victims computer, it will install it for him. What I have also noticed is that this sample in particular uses Zelix for obfuscation, whereas others use Allatori. 


# Attachments

```

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
public class Main {

    public static byte[] b(String string, byte[] byArray) throws Exception {
        int n;
        ByteBuffer byteBuffer;
        block4: {
            byteBuffer = ByteBuffer.wrap(byArray);
            n = byteBuffer.getInt();
            if (n >= 12 && n <= 16) break block4;
            throw new IllegalArgumentException("Nonce size is incorrect. Make sure that the incoming data is an AES encrypted file.");
        }
        byte[] byArray2 = new byte[n];
        byteBuffer.get(byArray2);
        SecretKey secretKey = a(string, byArray2);
        byte[] byArray3 = new byte[byteBuffer.remaining()];
        byteBuffer.get(byArray3);
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
        IvParameterSpec ivParameterSpec = new IvParameterSpec(byArray2);
        cipher.init(2, (Key)secretKey, ivParameterSpec);
        return cipher.doFinal(byArray3);

    }

    public static SecretKey a(String string, byte[] byArray) throws Exception {
        PBEKeySpec pBEKeySpec = new PBEKeySpec(string.toCharArray(), byArray, 65536, 128);
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
        byte[] byArray2 = secretKeyFactory.generateSecret(pBEKeySpec).getEncoded();
        return new SecretKeySpec(byArray2, "AES");
    }


    public static void main(String[] args) throws Exception {
        boolean b1 = true;
        InputStream inputStream = Main.class.getResourceAsStream("config.txt");
        StringBuilder stringBuilder = new StringBuilder();
        byte[] byArray = new byte[1024];
        do {
            int n;
            if ((n = inputStream.read(byArray,0,byArray.length)) == -1) {
                inputStream.close();
                if(!b1) break;
            }
            stringBuilder.append(new String(byArray,0,n));
        } while(!b1);
        byte[] byArray2 = DatatypeConverter.parseBase64Binary((String) stringBuilder.toString());
        byte[] byArray3 = b("strigoi", byArray2);
        String string = new String(byArray3, "UTF-8");
        System.out.println(string.split("\\|"));
        //79[.]110[.]62[.]41|7205|hxxp://jbfrost[.]live/strigoi/server/?hwid=1&lid=m&ht=5|127[.]0[.]0[.]1|7205|true|true|true|0EHD-YGMT-QM81-RD7S-07I6

    }
}
```
